
// mod generic_type;
// mod modules;
//mod error_handlings;
//mod modules;
//mod enums;
//mod structs;
//mod point_reference; 
//mod loops;
// mod conditionals;
//mod function;
//mod data_types;
//mod variable;
//use structs::Animal;
// use modules::movies::play;

mod generic_type;

fn main() {


    

  

    // generic_type::largest();
    generic_type::main();


    // modules::movies::play("Arive".to_string(),"BadBoys".to_string(), "Cats Drive".to_string() , "Dictator".to_string());
    //error_handlings::run();
    //modules::run();
    //enums::run();
    // structs::run();
    //point_reference::run();
    //loops::run(); 
    // crate::conditionals::run();
    //functions::haa(44,12);
    //data_types::run();
    //variable::run();

    // let x = Animal("HORSE".to_string(),"CAT".to_string());
    // println!("{:?}",x,);
}







/*#[derive(Debug)]
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x 

    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
   

}*/





